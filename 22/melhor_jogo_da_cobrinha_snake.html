<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Melhor Jogo da Cobrinha — Corrigido e Seguro</title>
  <meta name="description" content="Versão do jogo da cobrinha com inicialização segura, checagens contra null e painel de diagnóstico." />
  <style>
    :root{--bg:#081221;--panel:#0f1724;--accent:#6c7bff;--accent2:#54e1c8;--muted:#9aa3c8;--glass:rgba(255,255,255,0.03)}
    *{box-sizing:border-box} html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#051022);color:#eaf0ff}
    .wrap{max-width:1100px;margin:18px auto;padding:16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 8px 30px rgba(80,90,200,.18)}
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .layout{display:grid;gap:16px;margin-top:16px}@media(min-width:880px){.layout{grid-template-columns:1fr 360px}}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:14px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}.btn{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer;font-weight:700}.btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#041022;border:1px solid transparent}
    .canvas-wrap{display:flex;align-items:center;justify-content:center;padding:8px}canvas{background:#02030a;border-radius:12px;border:6px solid rgba(255,255,255,0.02);box-shadow:0 20px 50px rgba(0,0,0,.6);display:block;max-width:100%;height:auto}
    .hud{display:flex;justify-content:space-between;gap:8px;margin-top:10px;align-items:center}.hud .left,.hud .right{display:flex;gap:8px;align-items:center}.stat{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-weight:700}
    .pad{display:none;margin-top:12px;justify-content:center}@media(max-width:880px){.pad{display:flex;gap:8px}}.note{font-size:12px;color:var(--muted)}
    .diag{margin-top:12px;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    pre{white-space:pre-wrap;color:#ffd;max-height:240px;overflow:auto}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Melhor Jogo da Cobrinha — Corrigido</h1>
          <p class="lead">Inicialização segura, prevenção de erros e diagnóstico embutido.</p>
        </div>
      </div>
      <div class="controls">
        <button id="btnStart" class="btn primary">Iniciar</button>
        <button id="btnPause" class="btn">Pausar</button>
        <div class="stat">Pontos: <span id="score">0</span></div>
        <div class="stat">Recorde: <span id="best">0</span></div>
      </div>
    </header>

    <div class="layout">
      <main class="card">
        <div class="canvas-wrap">
          <canvas id="game" width="720" height="720" aria-label="Jogo da cobrinha"></canvas>
        </div>

        <div class="hud">
          <div class="left">
            <div class="stat">Velocidade: <span id="velLabel">Normal</span></div>
            <div class="stat">Nível: <span id="level">1</span></div>
          </div>
          <div class="right">
            <div class="stat">Tamanho: <span id="length">0</span></div>
            <div class="note">Teclas: ↑ ↓ ← → ou W A S D • Pausa: P</div>
          </div>
        </div>

        <div class="pad" id="pad" aria-hidden="false">
          <button data-dir="up" aria-label="cima">↑</button>
          <button data-dir="left" aria-label="esquerda">←</button>
          <button data-dir="right" aria-label="direita">→</button>
          <button data-dir="down" aria-label="baixo">↓</button>
        </div>

        <div class="diag">
          <button id="runTests" class="btn">Executar diagnóstico</button>
          <div id="testOutput" style="margin-top:8px; display:none"><pre id="testLog"></pre></div>
        </div>
      </main>

      <aside class="card">
        <h3>Configurações</h3>
        <div style="margin:8px 0">
          <label>Grade: <span id="gridVal">20</span></label>
          <input id="grid" type="range" min="10" max="40" value="20" style="width:100%" />
        </div>
        <div style="margin:8px 0">
          <label>Velocidade: <span id="speedVal">5</span></label>
          <input id="speed" type="range" min="1" max="10" value="5" style="width:100%" />
        </div>
        <div style="margin:8px 0">
          <label><input id="lethal" type="checkbox" checked /> Borda letal (morre ao bater)</label>
        </div>
        <div style="margin-top:12px">
          <button id="soundToggle" class="btn">Som: ON</button>
          <button id="btnResetScore" class="btn" style="margin-left:8px">Redefinir recorde</button>
        </div>

        <hr style="margin-top:12px;border:none;border-top:1px solid rgba(255,255,255,0.03)" />
        <div style="color:var(--muted);font-size:13px;margin-top:8px">Relate o erro exibido no console se algo estranho acontecer.</div>
      </aside>
    </div>

    <footer style="margin-top:12px;color:var(--muted)">Versão corrigida — eu adicionei proteção contra valores nulos e um painel de diagnóstico.</footer>
  </div>

  <script>
  (function(){
    'use strict';
    // DOM refs
    const canvas = document.getElementById('game');
    if(!canvas){ document.body.innerHTML = '<h2>Erro: canvas não encontrado</h2>'; return; }
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const velLabel = document.getElementById('velLabel');
    const levelEl = document.getElementById('level');
    const lengthEl = document.getElementById('length');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const gridInput = document.getElementById('grid');
    const speedInput = document.getElementById('speed');
    const lethalCheckbox = document.getElementById('lethal');
    const soundToggle = document.getElementById('soundToggle');
    const pad = document.getElementById('pad');
    const runTestsBtn = document.getElementById('runTests');
    const testOutput = document.getElementById('testOutput');
    const testLog = document.getElementById('testLog');
    const resetScoreBtn = document.getElementById('btnResetScore');

    // Safe defaults
    let CELL = parseInt(gridInput.value,10) || 20;
    let SPEED = parseInt(speedInput.value,10) || 5;
    let LETHAL = lethalCheckbox?.checked ?? true;

    let skin = localStorage.getItem('snake-skin') || 'classic';
    let soundOn = (localStorage.getItem('snake-sound')||'1')==='1';
    let best = Number(localStorage.getItem('snake-best')||0);
    if(bestEl) bestEl.textContent = best;

    // Game state
    let cols = CELL, rows = CELL, scale = 1;
    let snake = [], dir = {x:0,y:0}, apple = null;
    let running = false, paused = false, points = 0, level = 1;
    let lastMove = 0, moveInterval = 200;

    // Audio (safe)
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioCtx ? new AudioCtx() : null;
    function beep(freq, duration=0.08, type='sine', gain=0.12){ try{ if(!audioCtx || !soundOn) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>o.stop(), duration*1000); }catch(e){ console.warn('beep failed', e); } }

    // Defensive rendering: don't crash if apple/snake missing
    function render(){ try{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // background
        ctx.fillStyle = '#050617'; ctx.fillRect(0,0,canvas.width,canvas.height);
        if(!apple){ // show a subtle hint while apple is not set
          ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.font = '14px system-ui'; ctx.fillText('Gerando maçã...', 12, 20);
        } else {
          const ax = apple.x * scale, ay = apple.y * scale;
          if(Number.isFinite(ax) && Number.isFinite(ay)) drawRoundedRect(ax+scale*0.12, ay+scale*0.12, scale*0.76, scale*0.76, Math.max(2, scale*0.18), '#ff5a8b');
        }

        if(Array.isArray(snake) && snake.length>0){
          for(let i=0;i<snake.length;i++){
            const s = snake[i];
            if(!s || typeof s.x!=='number' || typeof s.y!=='number') continue; // skip invalid
            const x = s.x*scale, y = s.y*scale;
            const isHead = i===snake.length-1;
            drawSnakeSegment(x,y,scale,isHead,i);
          }
        }

        // grid lines for clarity on larger sizes
        if(scale>12){ ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth=1; for(let i=1;i<cols;i++){ ctx.beginPath(); ctx.moveTo(i*scale,0); ctx.lineTo(i*scale,canvas.height); ctx.stroke(); } for(let j=1;j<rows;j++){ ctx.beginPath(); ctx.moveTo(0,j*scale); ctx.lineTo(canvas.width,j*scale); ctx.stroke(); } }
      }catch(err){ showError(err); }
    }

    function drawRoundedRect(x,y,w,h,r,color){ ctx.fillStyle=color; roundRect(ctx,x,y,w,h,r); ctx.fill(); }
    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    function drawSnakeSegment(x,y,sz,isHead,index){ try{
      if(skin==='classic'){ const grad = ctx.createLinearGradient(x,y,x+sz,y+sz); grad.addColorStop(0,'#6c7bff'); grad.addColorStop(1,'#54e1c8'); ctx.fillStyle=grad; }
      else if(skin==='neon'){ const grad = ctx.createLinearGradient(x,y,x+sz,y+sz); grad.addColorStop(0,'#ff5a8b'); grad.addColorStop(1,'#ffd166'); ctx.fillStyle=grad; }
      else if(skin==='forest'){ const grad = ctx.createLinearGradient(x,y,x+sz,y+sz); grad.addColorStop(0,'#2ecc71'); grad.addColorStop(1,'#00703a'); ctx.fillStyle=grad; }
      else ctx.fillStyle='#9aa3c8';
      drawRoundedRect(x+sz*0.08,y+sz*0.08,sz*0.84,sz*0.84,Math.max(2,sz*0.18),ctx.fillStyle);
      if(isHead){ const eyeX = x + sz*0.62; const eyeY = y + sz*0.28; const eyeR = Math.max(1, Math.floor(sz*0.08)); ctx.fillStyle = '#051022'; ctx.beginPath(); ctx.arc(eyeX,eyeY,eyeR,0,Math.PI*2); ctx.fill(); }
    }catch(e){ console.warn('draw segment failed', e); }

    function computeScale(){ cols = rows = Math.max(8, Math.min(60, CELL)); scale = Math.floor(canvas.width / cols) || 1; }
    function resizeCanvas(){ const maxW = Math.min(window.innerWidth - 48, 900); const size = Math.max(280, Math.min(maxW, 720)); canvas.width = size; canvas.height = size; computeScale(); render(); }

    // initialize snake centered
    function resetState(){ cols = rows = CELL; snake = []; const cx = Math.floor(cols/2); const cy = Math.floor(rows/2); snake.push({x:cx-1,y:cy}); snake.push({x:cx,y:cy}); snake.push({x:cx+1,y:cy}); dir = {x:0,y:0}; points = 0; level = 1; updateHUD(); placeApple(); }

    function placeApple(){ // ensure apple not on snake, robust
      if(!Array.isArray(snake)) snake = [];
      let tries = 0; let candidate = null;
      do{ candidate = {x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows)}; tries++; if(tries>1000) break; } while(snake.some(s=>s && s.x===candidate.x && s.y===candidate.y));
      apple = candidate; return apple;
    }

    function updateHUD(){ if(scoreEl) scoreEl.textContent = points; if(levelEl) levelEl.textContent = level; if(lengthEl) lengthEl.textContent = (Array.isArray(snake)?snake.length:0); if(velLabel) velLabel.textContent = speedLabel(SPEED); }
    function speedLabel(v){ if(v<=3) return 'Lento'; if(v<=6) return 'Normal'; if(v<=8) return 'Rápido'; return 'Insano'; }

    // Game loop
    function loop(ts){ try{
      if(!running) return; if(paused){ render(); requestAnimationFrame(loop); return; }
      if(!lastMove) lastMove = ts; const elapsed = ts - lastMove; moveInterval = Math.max(40, 360 - (SPEED*30) - ((level-1)*8));
      if(elapsed >= moveInterval){ step(); lastMove = ts; }
      render(); requestAnimationFrame(loop);
    }catch(err){ showError(err); running=false; } }

    function step(){ try{
      if(!Array.isArray(snake) || snake.length===0){ console.warn('Snake vazio — reiniciando estado'); resetState(); return; }
      if(dir.x===0 && dir.y===0) return; // not moving
      const tail = snake[0]; const headPos = snake[snake.length-1]; if(!headPos){ console.warn('Head inválido, reiniciando'); resetState(); return; }
      const head = {x: headPos.x + dir.x, y: headPos.y + dir.y};
      // lethal walls or wrap
      if(LETHAL){ if(head.x<0 || head.y<0 || head.x>=cols || head.y>=rows){ onGameOver(); return; } }
      else { head.x = (head.x + cols) % cols; head.y = (head.y + rows) % rows; }
      // self collision
      if(snake.some(s=>s.x===head.x && s.y===head.y)){ onGameOver(); return; }
      snake.push(head);
      // eat apple
      if(apple && head.x===apple.x && head.y===apple.y){ points += 10 * Math.max(1,level); beep(900, 0.06, 'square', 0.14); if((points/10) % 5 === 0){ levelUp(); } placeApple(); }
      else { snake.shift(); }
      updateHUD();
    }catch(err){ showError(err); } }

    function levelUp(){ level++; beep(1100,0.09,'sawtooth',0.16); }

    function onGameOver(){ running=false; paused=false; btnStart.textContent = 'Iniciar'; beep(220,0.35,'sine',0.2); if(points > best){ best = points; localStorage.setItem('snake-best', String(best)); if(bestEl) bestEl.textContent = best; alert('Novo recorde! ' + best); } else { alert('Fim de jogo! Pontos: ' + points); } }

    // Controls
    function setDir(d){ // prevent reversing into yourself
      try{ if(!Array.isArray(snake) || snake.length<2){ dir = d; return; } const head = snake[snake.length-1]; const neck = snake[snake.length-2]; if(head.x + d.x === neck.x && head.y + d.y === neck.y) return; dir = d; }catch(e){ console.warn('setDir failed', e); }
    }

    window.addEventListener('keydown', (e)=>{ const k = e.key.toLowerCase(); if(['arrowup','w'].includes(k)) setDir({x:0,y:-1}); if(['arrowdown','s'].includes(k)) setDir({x:0,y:1}); if(['arrowleft','a'].includes(k)) setDir({x:-1,y:0}); if(['arrowright','d'].includes(k)) setDir({x:1,y:0}); if(k==='p'){ togglePause(); } });
    pad.addEventListener('click', (e)=>{ const d = e.target.dataset.dir; if(!d) return; if(d==='up') setDir({x:0,y:-1}); if(d==='down') setDir({x:0,y:1}); if(d==='left') setDir({x:-1,y:0}); if(d==='right') setDir({x:1,y:0}); });

    // touch swipe
    let touchStart = null;
    canvas.addEventListener('touchstart', (e)=>{ const t = e.touches[0]; touchStart = {x:t.clientX, y:t.clientY}; });
    canvas.addEventListener('touchend', (e)=>{ if(!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x, dy = t.clientY - touchStart.y; if(Math.abs(dx)>Math.abs(dy)){ if(dx>20) setDir({x:1,y:0}); else if(dx<-20) setDir({x:-1,y:0}); } else { if(dy>20) setDir({x:0,y:1}); else if(dy<-20) setDir({x:0,y:-1}); } touchStart=null; });

    // UI bindings
    btnStart.addEventListener('click', ()=>{ if(!running){ startGame(); } else { restartGame(); } });
    btnPause.addEventListener('click', togglePause);
    gridInput.addEventListener('input', ()=>{ CELL = parseInt(gridInput.value,10) || 20; document.getElementById('gridVal').textContent = CELL; resizeCanvas(); resetState(); render(); });
    speedInput.addEventListener('input', ()=>{ SPEED = parseInt(speedInput.value,10) || 5; document.getElementById('speedVal').textContent = SPEED; updateHUD(); });
    lethalCheckbox.addEventListener('change', ()=>{ LETHAL = lethalCheckbox.checked; });
    soundToggle.addEventListener('click', ()=>{ soundOn = !soundOn; localStorage.setItem('snake-sound', soundOn? '1':'0'); soundToggle.textContent = soundOn? 'Som: ON' : 'Som: OFF'; });
    resetScoreBtn.addEventListener('click', ()=>{ if(confirm('Redefinir recorde?')){ best = 0; localStorage.setItem('snake-best','0'); if(bestEl) bestEl.textContent = '0'; } });

    function startGame(){ try{ running = true; paused = false; btnStart.textContent = 'Reiniciar'; lastMove = 0; resetState(); requestAnimationFrame(loop); }catch(e){ showError(e); } }
    function restartGame(){ running = false; paused = false; resetState(); running = true; lastMove = 0; requestAnimationFrame(loop); }
    function togglePause(){ if(!running) return; paused = !paused; btnPause.textContent = paused? 'Continuar' : 'Pausar'; }

    // Diagnostics / tests
    function logTest(msg){ testOutput.style.display = 'block'; testLog.textContent += msg + '
'; }
    function clearTestLog(){ testLog.textContent = ''; testOutput.style.display = 'none'; }
    runTestsBtn.addEventListener('click', ()=>{
      clearTestLog(); logTest('Executando diagnósticos...');
      try{
        // Test 1: resetState -> apple exists and not colliding
        resetState(); logTest('Test 1: resetState executado.');
        if(!apple) logTest('FAIL: apple é null após resetState'); else if(snake.some(s=>s.x===apple.x && s.y===apple.y)) logTest('FAIL: apple colide com a cobra'); else logTest('OK: apple criada corretamente em ' + JSON.stringify(apple));

        // Test 2: step sem direção não altera tamanho
        const before = snake.length; dir = {x:0,y:0}; step(); if(snake.length===before) logTest('OK: step sem direção manteve tamanho'); else logTest('FAIL: step sem direção alterou a cobra');

        // Test 3: colisão com parede (modo letal) simulação
        CELL = 6; resizeCanvas(); resetState(); // small grid
        // place head at edge moving out
        snake = [{x:0,y:0},{x:1,y:0},{x:2,y:0}]; dir = {x:-1,y:0}; LETHAL = true; points = 0; let over=false;
        const oldAlert = window.alert; window.alert = ()=>{ over=true; }; step(); window.alert = oldAlert; if(over) logTest('OK: colisão com parede detectada (letal)'); else logTest('FAIL: colisão com parede NÃO detectada (letal)');

        // restore
        CELL = parseInt(gridInput.value,10) || 20; resizeCanvas(); resetState(); logTest('Diagnóstico finalizado.');
      }catch(e){ logTest('Erro durante diagnósticos: '+(e&&e.message)); }
    });

    // Error overlay / console helper
    function showError(err){ console.error(err); try{ alert('Erro: '+(err && err.message)); }catch(e){} }

    // initial setup
    function init(){ CELL = parseInt(gridInput.value,10) || 20; SPEED = parseInt(speedInput.value,10) || 5; LETHAL = lethalCheckbox.checked; computeScale(); resetState(); updateHUD(); render(); // warm audio
      window.addEventListener('pointerdown', ()=>{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }, {once:true});
      window.addEventListener('resize', ()=>{ resizeCanvas(); render(); });
    }

    // initial call after DOM ready
    try{ init(); }catch(err){ showError(err); }

    // expose for debugging
    window.__snake = { resetState, reset: resetState, step, render, getState: ()=>({snake,apple,points,level}) };
  })();
  </script>
</body>
</html>
